불연속적인 할당 방식으로 [[외부 단편화]], 압축과 관련된 문제를 피할 수 있음
## 기본 방법
- **frame** : physical memory를 나누는 동일한 크기의 블록
- **page** : logical memory를 나누는 동일한 크기의 블록
- 주소 = **페이지 번호**+ **페이지 오프셋**
	페이지 번호, 오프셋을 통해 페이지 테이블에 접근
	![](https://i.imgur.com/ibcipFJ.png)
- **페이지 테이블**을 통해 logical address -> physical address 변환
	각 프레임의 시작 주소를 가지고 있음
	![](https://i.imgur.com/qGpY3A9.png)
## 변환
실제 주소 = 프레임 번호 + 오프셋
![](https://i.imgur.com/69DT6FC.png)

1. 페이지 번호 _p_ 를 추출하여 페이지 테이블의 인덱스로 사용
2. 페이지 테이블에서 해당 프레임 번호 _f_ 를 추출
3. 논리 주소의 페이지 번호 _p_ 를 프레임 번호 _f_ 로 변경
## 물리주소 구성
프레임, 페이지 크기는 하드웨어에 의해 정해지며 **2의 거듭제곱**으로 4KB ~ 1GB 사이
논리 주소 공간의 크기가 $2^m$이고, 페이지 크기가 $2^n$일 경우
- **페이지 번호** : 상위 $m-n$ 비트
- **페이지 오프셋** : 하위 $n$ 비트
![](https://i.imgur.com/gBUwl8E.png)
> ex)
> ![](https://i.imgur.com/VhwKKt3.png)
> - 논리 주소 공간의 크기 : $2^4$
> - 페이지 크기 : $2^2$
>
> => 페이지 번호 : 상위 $4-2 = 2$ 비트
> => 페이지 오프셋 : 하위 $2$ 비트
>>
> 1) 논리주소 **0**
> 	- 이진수 : 0000
> 	- 상위 2비트 : 00 => 페이지 번호 : 0
> 	- 하위 2비트 : 00 => 오프셋 : 0
> 	- page table에 의해 페이지 번호 0은 프레임 5로 사상
> 	- **실제 주소 : 20(= $(5 * 4) + 0$)**
> 2) 논리주소 **3**
> 	- 이진수 : 0011
> 	- 상위 2비트 : 00 => 페이지 번호 : 0
> 	- 하위 2비트 : 11 => 오프셋 : 3
> 	- page table에 의해 페이지 번호 0은 프레임 5로 사상
> 	- **실제 주소 : 23(= $(5 * 4) + 3$)**
> 3) 논리주소 **4**
> 	- 이진수 : 0100
> 	- 상위 2비트 : 01 => 페이지 번호 : 1
> 	- 하위 2비트 : 00 => 오프셋 : 0
> 	- page table에 의해 페이지 번호 1은 프레임 6로 사상
> 	- **실제 주소 : 24(=$(6 * 4) + 0)**
## 내부 단편화 발생
평균적으로 프로세스 당 반 페이지 정도의 내부 단편화 발생

> 페이지 크기 : 2,048B
> 프로세스 크기 : 72,766B
>
> => 온전히 할당되는 프레임 : 35개
> => 남는 페이지 크기 : 1,086B
> => 36번째 프레임은 962B의 내부 단편화 발생

페이지 크기 🔺 : 잦은 내부 단편화, 디스크 입장에서 효율적
페이지 크기 🔻 : 페이지 테이블의 크기가 커져 공간 낭비
## 프레임 테이블
- 운영체제의 물리 메모리 관리를 위해 존재
- 시스템에 하나 뿐인 자료구조
- 각 프레임 당 비어 있는지 여부, 할당 되었는지 여부, 할당 되었다면 어느 프로세스의 어느 페이지에 할당 되었는지를 표시

> 💡 페이지 테이블은 프로세스마다 존재
## 페이지 테이블 구현
### 1️⃣ 하드웨어 레지스터
- CPU의 하드웨어 레지스터에 테이블 정보 직접 저장
- 레지스터에 의해 빠르게 접근되므로 주소 변환 과정이 매우 빠름
- 모든 페이지 테이블 레지스터 값을 저장하고 복원해야 하므로 [[Context Switch]] 시간 증가
### 2️⃣ PTBR
- Page-Table Base Register
- 페이지 테이블은 메모리에 상주하며 PTBR이 페이지 테이블의 시작 주소를 가리킴
- 다른 페이지 테이블을 사용할 때, PTBR만 변경하면 되므로 Context Switch 시간 감소
- 메모리 액세스 시간이 느려질 수 있음
	> 1. 페이지 번호를 기준으로 PTBR 오프셋의 값을 사용하여 페이지 테이블의 항목 찾음
	> 2. 얻은 프레임 번호와 페이지 오프셋을 결합하여 실제 주소 생성
	> 3. 메모리에서 원하는 위치에 액세스
	>    
	=> **두 번**의 메모리 액세스
	
	#### TLB
	- Translation Look-Aside Buffer
	- 소형 하드웨어 캐시
	- 매우 빠른 연관 메모리로 **키**(Key), **값**(Value)로 구성
	- 내부 키(페이지 번호)와 연관된 값(프레임 번호)를 알려줌
	- TLB에 찾으려는 페이지 번호가 없으면(**TLB미스**), 페이지 테이블에 대한 메모리 참조가 이루어짐
		![](https://i.imgur.com/tGYUCfB.png)
	- 새로운 페이지 테이블이 선택(Context Switch) 시, 모든 TLB는 전부 flush됨
## 보호
### 1️⃣ 보호 비트
1. 페이지에 쓰기가 허용되는지 검사 -> 부적절할 경우 트랩 발생
2. 적절한 범위인지를 검사 (**유/무효 비트**)
	> 14비트의 주소 공간 (0 ~ 16,383)
	> 프로그램이 0 ~ 10,468 사용 가능
	> 페이지 크기 : 2KB
	> 
	> => 페이지 0 ~ 5의 주소를 페이지 테이블을 통해 정상적으로 사상되나 6, 7의 주소에 매핑 시도 시 트랩 발생
	> ![](https://i.imgur.com/FjhPkQw.png)
### 2️⃣ PTLR
- Page Table Length Register
- 페이지 테이블의 크기를 나타내는 레지스터
- 유효한 주소 검사를 위해 모든 논리 주소 값이 PTLR과 비교되며, 오류 발생 시 트랩 발생
## 페이지 테이블 구조
현대 컴퓨터의 주소 공간이 커지며 페이지 테이블의 크기가 비례하게 증가하는 상황에서 메인 메모리에 연속적으로 페이지 테이블을 위한 공간을 할당하기 어려워짐
-> 테이블을 여러 개의 조각으로 나눔

### 1️⃣ 2단계 페이징 기법
![](https://i.imgur.com/wmcU2P1.png)
- 페이지 테이블 자체가 다시 페이징되는 방법
>**32비트 기계**
>논리 주소 공간의 크기 : $2^{32}$
>페이지 크기 : 4KB = $2^{12}$
>
=> 페이지 번호 : 상위 $32 - 12 = 20$ 비트
=> 페이지 오프셋 : 하위 $12$ 비트
>
>![](https://i.imgur.com/d3H1oz8.png)
=> 상위 20비트 = 상위 10비트 + 하위 10비트
>>상위 10비트(`p1`) -> 상위 페이지 테이블의 인덱스
>>하위 10비트(`p2`) -> 하위 페이지 테이블 내의 인덱스
>
=> 하위 12비트(`d`) = 오프셋

- 64비트 구조에서는 2단계 페이징이 부적합
	-> 다단계 페이징으로 구현할 수 있으나 너무나 많은 단계가 생겨남
### 2️⃣ 해시 페이지 테이블
- 주소 공간이 32비트보다 커질 경우 가상 주소를 해시로 사용
- 각 항목은 연결 리스트로 구현
- 각 원소는 세 개의 필드를 가짐
	1) 가상 페이지 번호
	2) 사상되는 페이지 프레임 번호
	3) 연결 리스트상의 다음 포인터

![](https://i.imgur.com/1lkmAi7.png)
1. 가상 주소 공간으로부터 페이지 번호가 오면 이를 해싱
2. 해시 페이지 테이블에서 연결 리스트를 따라가며 첫 번째 원소와 가상 페이지 번호를 비교
3. 일치되면 그에 대응하는 페이지 프레임 번호를 가져와 물리 주소를 얻고, 일치되지 않으면 다음 원소 탐색

> 💡 `q`와 `p`는 해시 충돌로 인해 같은 버킷에 체이닝됨
### 3️⃣ 역 페이지 테이블
- 시스템 내에 단 하나의 페이지 테이블만 존재
- 메모리에서 훨씬  작은 공간을 점유하지만 물리 주소에 따라 정렬되어 있는 테이블 전체를 탐색해야 하기 때문에 주소 변환 시간이 오래 걸림
- 두 개의 필드
	1) 프로세스의 ID (PID)
	2) 그 프레임에 올라와 있는 페이지 주소

![](https://i.imgur.com/Qp86Uhc.png)
1. 메모리 참조 발생 시, <PID, PageNumber>의 쌍으로 이루어진 가상 주소가 전달
2. 역 페이지 테이블에서 일치하는 것이 있는지 검색
3. 일치하는 것이 i번째 엔트리에서 발견된다면 물리 주소는 <i, offset>이 되고, 일치하는 것이 없다면 잘못된 메모리 접근으로 간주

> 💡 한 번에 하나의 가상 주소만 물리 주소에 매핑될 수 있음