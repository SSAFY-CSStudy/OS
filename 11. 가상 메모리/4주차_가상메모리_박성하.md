# 가상 메모리란?
메모리를 추상화하여 매우 큰 메모리로 보이게 만드는 것
주기억장치보다 큰 메모리 영역을 제공
![](https://i.imgur.com/K7o6Uf8.png)

### 장점
1. 물리 메모리 크기에 제약을 받지 않게 됨
2. 더 많은 프로그램을 동시에 수행할 수 있음

## 메모리 적재 방법
### 1️⃣ 시작 시 모두 적재
프로그램의 전체가 메모리에 있을 필요가 없을 수도 있음
### 2️⃣ 요구 페이징
필요한 페이지만 필요할 때 적재
#### Page fault
프로세스가 실행되는 동안 일부 페이지는 메모리에 존재하고, 일부 페이지는 보조저장장치(스왑 공간)에 있음<br>
이들을 구분하기 위해 **유효/무효 비트** 기법 사용
![](https://i.imgur.com/QnRpUWL.png)<br>
무효 비트 접근 시, mmu가 **page fault 트랩** 발생 -> 운영체제가 페이지를 적재하는데 실패했기 때문에 발생

![](https://i.imgur.com/GuVWvt6.png)
1. PCB 확인 후, 메모리 참조의 유/무효 확인
2. 무효한 페이지라면 프로세스를 중단하며 페이지가 아직 메모리에 올라오지 않은 상태라면 보조저장장치로부터 가져옴
	>1) 운영체제에 트랩 요청
	>2) 레지스터, 프로세스 상태 저장
	>3) 인터럽트 원인이 페이지 폴트임을 확인
	>4) 페이지 참조가 유효한지 확인 후, 보조저장장치에 있는 페이지의 위치 확인
3. 빈 가용 프레임을 찾음
	> **가용 프레임 리스트**<br>
	> ![](https://i.imgur.com/fV0ZWbs.png)<br>
	> 가용 프레임 요청 시, 리스트의 크기 감소
	> 1) 해당 프레임의 읽기 요구를 요청
	> 2) 읽기 차례가 돌아올 때까지 대기 큐에서 기다림
	> 3) 대기 큐에서 기다리는 동안 CPU 코어는 다른 사용자에게 할당
	> 4) 저장장치가 해당 프레임의 읽기를 완료했다는 I/O 신호 송신
	> 5) CPU 코어가 다른 사용자에게 할당되었을 경우 해당 작업의 레지스터와 프로세스 상태 저장
	> 6) 인터럽트가 보조저장장치로부터 왔다는 것을 확인
4. 실제 메모리에 해당 페이지를 적재
5. 보조저장장치 읽기 종료 후, 해당 페이지가 메모리에 있다는 것을 알리기 위해 페이지 테이블을 갱신
6. 트랩에 의해 중단되었던 명령어 재수행
	> 1) CPU 코어가 자기 차례에 오기까지 기다림
	> 2) CPU 코어가 자기 차례에 오면 위에서 저장시켜 두었던 레지스터, 프로세스 상태, 페이지 테이블을 복원하고 명령어 재실행

> 💡 페이지 폴트 발생이 잦을 시, 시스템 성능이 저하되지만 **참조의 지역성** 성질에 의해 실제적으로 과도한 성능 저하는 없는 편

## 페이지 교체 방법
빈 프레임이 없다면 현재 사용되고 있지 않는 프레임을 찾아 지워 버림<br>
해당 프레임의 내용을 스왑 공간에 쓰고 메모리에 더이상 존재하지 않음을 나타내기 위해 페이지 테이블 업데이트<br>
![](https://i.imgur.com/RChbjr1.png)<br>
빈 프레임이 없는 경우 디스크 접근 **2회** 발생
1) 프레임을 비울 때
2) 페이지를 읽어 들일 때

페이지 폴트 시간이 2배 소요되며 접근 시간 증가<br>
-> **변경 비트**를 통해 해결
### 변경 비트
CPU가 페이지 내의 어떠한 바이트라도 쓰게 되면 페이지가 변경되었음을 나타내기 위해 사용
1. 희생시킬 페이지 선정 후 변경 비트 확인
2. 변경 비트 설정 시, 보조저장장치에 기록 (기존 순서)
3. 변경 비트 미설정 시, 보조저장장치에 기록하는 과정 없이 제거
### 페이지 교체 알고리즘
일반적으로 페이지 폴트율이 가장 낮은 것을 선정
#### 1️⃣ FIFO
메모리에 올라온 지 가장 오래된 페이지를 내쫓음
![](https://i.imgur.com/Zblyygv.png)
**장점**<br>
프로그램 하기 쉬우며, 이해하기 쉬움

**단점**<br>
성능이 좋지 않음 -> 교체된 페이지가 초기화된 뒤 계속해서 자주 사용되는 페이지일 수 있음

>**Belady의 모순**
>![](https://i.imgur.com/cSRnryN.png)<br>
>더 많은 프레임을 주었는데(3 -> 4), 페이지 폴트는 증가함(9 -> 10)<br>
>프로세스에 더 많은 프레임을 할당하면 성능이 좋아질 것이라고 생각하는 현상
>
#### 2️⃣ 최적 페이지 교체
Belady의 모순이 발생하지 않는 정책<br>
앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체<br>
**OPT** 또는 **MIN**으로 불림
![](https://i.imgur.com/v2WQObJ.png)
**장점**<br>
가장 낮은 페이지 폴트율 보장

**단점**<br>
실제 구현이 어려움

> 💡 다른 정책들이 최악의 상황에도 최적 페이지 교체와 평균 4.7%밖에 차이나지 않음

#### 3️⃣ LRU 페이지 교체
Belady의 모순이 발생하지 않는 정책<br>
가장 오랜 기간 동안 사용되지 않은 페이지 교체<br>
페이지마다 마지막 사용 시간 유지
![](https://i.imgur.com/jQX0SzL.png)
**장점**<br>
FIFO 알고리즘보다 우수

**단점**<br>
하드웨어의 지원 필요
1. **counters**<br>
	페이지 항목마다 사용 시간 필드를 넣고 CPU에 counters 추가<br>
	메모리가 접근될 때마다 시간이 증가하며 페이지의 사용 시간 필드에 시간 레지스터 내용 복사<br>
	메모리 참조 시마다 메모리 쓰기 작업이 필요하며 테이블이 변경될 때마다 시간 값을 관리해야하고, 시간의 overflow 고려
2. **stack**<br>
	페이지 번호의 스택 유지<br>
	스택의 top은 가장 최근에 사용된 페이지며, bottom은 가장 오랫동안 이용되지 않은 페이지<br>
	중간에 항목을 제거해야할 수 있으므로 doubly linked list로 구현<br>

소프트웨어로 처리하기 위해 인터럽트 사용 시 모든 프로세스의 실행 속도 또한 저하

**LRU 근사 페이지 교체**<br>
참조 비트를 제공하는 형태
1. **부가적 참조 비트 알고리즘**<br>
	8비트에 대한 참조 비트 할당 후 일정 기간마다 타이머 인터럽트를 걸어 8비트를 오른쪽으로 시프트하며 참조 내용 기록
	> ex)<br>
	> `00000000` -> 페이지를 8번의 구간 동안 사용하지 않음<br>
	> `11111111` -> 페이지를 8번의 구간마다 최소한 한 번 이상 사용<br>
	> `11000100`인 페이지는 `01110111`인 페이지보다 최근에 사용 
2. **2차 기회 알고리즘**<br>
	참조 비트가 0이면 페이지를 교체하고 1이면 다시 한 번 기회를 주고 다음 FIFO 페이지로 넘어감<br>
	참조 비트가 계속 설정되어 있을 정도로 자주 사용되는 페이지는 전혀 교체되지 않음<br>
	순환 큐 이용하여 0 값의 참조 비트를 가진 페이지를 발견할 때까지 큐를 순회하고 참조 비트 값들이 1인 것은 0으로 변경	
	![](https://i.imgur.com/7WfBQxf.png)<br>
	최악의 경우 모든 비트가 1일 때 포인터 큐를 완전히 한 바퀴 돌게 되며 두 번째 순회 시 FIFO 알고리즘과 동일
3. **개선된 2차 알고리즘**
	참조 비트 + 변경 비트
	1) **(0, 0)** : 최근 사용 X, 최근 변경 X -> 교체하기 가장 좋은 페이지
	2) **(0, 1)** : 최근 사용 X, 최근 변경 O -> 페이지 교체 시 디스크에 내용을 기록해야 함
	3) **(1, 0)**: 최근 사용 O, 최근 변경 X -> 곧 다시 사용될 가능성이 높음
	4) **(1, 1)** : 최근 사용 O, 최근 변경 O -> 곧 다시 사용될 가능성이 높으며 제거 시 그 내용을 디스크에 먼저 기록해야 함
	가장 낮은 등급을 가진 페이지를 교체
#### 3️⃣ 계수 기반 페이지 교체
1. **LFU 알고리즘**
	참조 횟수가 가장 적은 페이지 교체
2. **MFU 알고리즘**
	참조 횟수가 가장 많은 페이지 교체
	적은 참조 횟수일 수록 앞으로 사용될 것이라는 판단에 근거

**단점**<br>
구현 시 비용이 많이 듦
## 프레임 할당
각 프로세스에 몇 프레임을 할당해야 하는가?

**제한사항 예시**
1. 가용 프레임 수보다 더 많이 할당할 수 없음
2. 최소한의 프레임을 할당해야 함
### 프레임 할당 알고리즘
#### 1️⃣ 균등 할당
모든 프로세스에 똑같은 개수 할당
#### 2️⃣ 비례 할당
프로세스의 크기 비율에 맞추어 할당
#### 3️⃣ 우선순위 할당
우선순위가 높은 프로세스에 더 많은 개수 할당
### 전역 vs 지역 할당
#### 1️⃣ 전역 교체
프로세스가 교체할 프레임을 다른 프로세스에 속한 프레임을 포함한 모든 프레임을 대상을 찾음<br>
다른 프로세스의 페이징 동작에 영향을 받음
#### 2️⃣ 지역 교체
프로세스가 자기에게 할당된 프레임 중에서만 교체될 희생자를 선택<br>
잘 안쓰는 프레임이 있을 시 낭비

> 💡일반적으로 전역 교체가 지역 교체보다 더 성능이 좋음
### 비균등 메모리 접근
**NUMA System** <br>
Non-Uniform Memory Access : 불균일 기억 장치 접근
#### 등장 배경
초기 CPU는 일반적으로 메모리보다 천천히 동작<br>
1960년대에 슈퍼 컴퓨터, 고속 컴퓨터가 개발되며 이 속도가 역전<br>
이 이후부터 CPU는 메모리에서 데이터를 다 가지고 올 때까지 기다려야 했음<br>
메모리에 접근하는 경우의 수를 줄이기 위해 캐시 메모리를 지속적으로 증가시키는 것과 캐시 미스를 줄이기 위한 알고리즘을 발전시킴<br>
하지만, 운영체제의 크기의 비약적인 증가와 애플리케이션의 크기 증가는 캐시를 통한 성능 향상을 압도함<br>
특히, 다중 프로세서일 경우에도 하나의 프로세서만이 메모리에 접근할 수 있기 때문에 대기 상태는 더 심각<br>
따라서 각각의 프로세서에 독립적인 별도의 메모리를 제공하는 NUMA system 등장
#### 원리
![](https://i.imgur.com/B9048ae.png)
- 램 모듈(Memory Bank)이 CPU 노드마다 별도로 존재
- 여러 개의 CPU 코어를 가진 NUMA 노드가 해당 노드에 직접 연결된 RAM을 가지며, 이를 로컬메모리로 사용
- 다른 노드가 타 로컬메모리에 접근하기 위해서 원격 접근이 필요하며, 로컬 메모리 접근보다 느림
#### 프레임 할당
프로세스가 마지막으로 실행된 CPU를 추적 후 이 CPU와 가까운 프레임을 할당한다면, 캐시 적중률이 높아지고 메모리 접근 시간 감소

## 스레싱
충분한 프레임이 존재하지 않고, 이미 활발하게 사용되는 페이지의 집합일 경우 발생하는 잦은 페이징 폴트
![](https://i.imgur.com/7NkpqSQ.png)
### 원인
1. 페이지 폴트 발생 시 CPU 이용률이 낮아짐
2. OS는 낮아지는 CPU 이용률을 해결하기 위해 다중 프로그래밍 정도를 높임
3. 페이지 폴트를 발생 시키는 CPU가 더욱 더 많아짐에 따라 CPU 이용률은 더욱 더 떨어짐
### 완화 방법
실제로 프로세스가 사용하고 있는 프레임의 수가 몇 개인지 알아봐야 함

**지역성 모델**<br>
프로세스가 실행될 때에는 항상 어떤 특정한 지역에서만 메모리를 집중적으로 참조
> ![](https://i.imgur.com/yp9Bnra.png)
>지역 (a)와 지역 (b)의 일부 페이지가 겹친다

캐싱의 기본원리 -> 데이터 참조가 어떤 패턴도 없이 무작위라면 캐싱은 무의미해짐
> 💡 지역성에 의거하여 페이지를 메모리에 적재하면 스레싱을 완화할 수 있음
#### 1️⃣ 작업 집합 모델
지역성을 토대로 하는 모델

**작업 집합** : 지역적으로 근처에 속해있으며 페이지가 활발하게 사용되는 페이지 집합
![](https://i.imgur.com/SucUYj7.png)
각 프로세스의 작업 집합 크기에 맞는 충분한 프레임을 할당한 후, 여분의 프레임이 있다면 더 할당하고 프로세스의 수가 너무 많다면 프로세스 중 하나를 선택해 작업 집합에서 제외

시간이 흐름에 따라 작업 집합이 변경됨
![](https://i.imgur.com/oxvYhNB.png)<br>
고점 : 새로운 지역으로 들어가 요구 페이징이 시작되는 경우<br>
저점 : 새로운 지역의 작업 집합이 메모리에 올라온 후 부재율이 낮아짐
#### 2️⃣ PFF(페이지 폴트 빈도)
작업 집합 모델보다 더 직접적으로 스레싱 조절

페이지 폴트율 🔺 : 프로세스가 너무 많은 프레임을 필요로 하는 상태<br>
페이지 폴트율 🔻 : 프로세스가 너무 많은 프레임을 갖고 있는 상태

![](https://i.imgur.com/7A7cWLI.png)<br>
페이지 폴트율의 상, 하한을 정해두고 상한을 넘으면 그 프로세스에 프레임을 더 할당하고, 하한보다 낮아지면 프로세스의 프레임 수를 줄임

> 💡 프로세스에 할당되었던 프레임은 높은 페이지 폴트율을 갖는 다른 프로세스들에게 분배