# 프로세스란?
- 실행 중인 프로그램
- 하나의 프로그램에 여러 개의 프로세스 생성 가능 -> 메모리 배치가 다를 수 있음

	ex) 웹 브라우저 여러 개 오픈
> 💡 프로그램 그 자체는 프로세스가 아님
### 메모리 배치
![](https://i.imgur.com/1DqLRq8.png)
1. **text** : 실행 코드
2. **data** : 전역 변수
3. **heap** : 프로그램 실행 중에 동적으로 할당되는 메모리
4. **stack** : 함수 호출 시 임시 데이터 저장장소
### 상태
![](https://i.imgur.com/Cb1vS1w.png)
1. **new** : 프로세스 생성
2. **ready** : 프로세스가 CPU에 할당되길 기다림
3. **running** : 명령어 실행
4. **waiting** : 프로세스가 어떤 이벤트가 일어나길 기다림
5. **terminated** : 프로세스 실행 종료
### PCB
- 프로세스 제어 블록 (Process Control Block)

    ![](https://i.imgur.com/3pnMwQf.png)
1. **프로세스 상태** : new, ready, running, waiting, terminated
2. **프로그램 카운터** : 프로세스가 다음에 실행할 명령어의 주소
3. **레지스터** : CPU가 현재 처리하고 있는 데이터. PC(프로그램 카운터)와 함께 나중에 프로세스가 다시 스케줄될 때 계속 올바르게 실행할 수 있도록 인터럽트 발생 시 저장
## 프로세스 스케줄링
### 다중 프로그래밍
- 각 CPU 코어는 한 번에 하나의 프로세스를 실행
- 초과 프로세스는 코어가 사용 가능해진 후 스케줄 될 때까지 waiting 상태
### 스케줄링 큐
- 연결리스트 <br>
    ![](https://i.imgur.com/H6NbkGb.png)
- 종료 시점에 모든 큐에서 제거되고 PCB 및 자원 반환
## 프로세스 생성
- 프로세스는 여러 개의 새로운 프로세스를 만들어 **트리**를 형성함
> 	- **부모 프로세스** : 생성하는 프로세스
> 	- **자식 프로세스** : 생성된 프로세스
- **pid** : 프로세스 식별자. idx로 사용됨
![](https://i.imgur.com/iV2hLoT.png)
- pid가 1인 **systemd**가 모든 프로세스의 루트 프로세스
### 메모리적 가능성
1. 자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가짐
2. 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가짐
### 메소드
![](https://i.imgur.com/iJPqzfV.png)
#### fork()
- 부모 프로세스의 복사본을 만듦
- 부모 프로세스의 모든 코드, 데이터, 힙 영역이 자식 프로세스로 복사
- fork() 이후에는 부모 프로세스와 자식 프로세스가 독립적으로 병렬 실행되어 각가 별도의 주소 공간을 가지게 됨
- 자식프로세스는 반환값으로 0을 반환
> 💡 프로세스 복제

#### exec()
- 프로세스의 현재 주소 공간을 새로운 프로그램으로 대체
- `fork()`와 결합하여 사용하며 부모 프로세스가 실행되는 동안 자식 프로세스가 다른 작업을 수행할 수 있음
> 💡 새로운 프로그램으로의 전환

#### wait()
- 부모 프로세스가 자식프로세스를 종료될 때까지 기다리기 위해 사용
## IPC
프로세스 간 통신 (Interprocess communication)
- 프로세스 간 데이터를 교환하는 기법
### 1. 공유 메모리
![](https://i.imgur.com/qi7t40u.png)
- 메모리 충돌을 고려해야하기 때문에 구현이 어려움
- 공유 메모리를 만들 때에만 시스템 콜 호출
#### 1) 세마포어
### 2. 메시지 전달
![](https://i.imgur.com/VppSFN8.png)
- 시스템 콜을 사용하여 구현되므로 느림
#### 1) Pipe
- 생산자(쓰기 종단), 소비자(읽기 종단) 형태
> 💡 일반 파이프는 단방형 통신이므로 양방향 통신이 필요할 경우 두 개의 파이프 사용
- 프로세스들이 통신하는 동안만 존재
- 파이프를 생성한 프로세스 이외에는 접근할 수 없기 때문에 부모 프로세스가 파이프를 생성하고 자식 프로세스와 통신하기 위해 사용
	![](https://i.imgur.com/NFkhNi5.png)
```bash
ls | grep "example"
```
#### 2) Named Pipe
- 부모-자식 관계 X -> 서로 관련이 없는 프로세스 간의 통신에 사용
- 통신 프로세스가 종료되더라도 계속 존재
```bash
# 명명된 파이프 생성
mkfifo my_fifo

# 한 터미널에서 데이터 쓰기
echo "Hello, Named Pipe!" > my_fifo

# 다른 터미널에서 데이터 읽기
cat my_fifo
```
#### 3) 소켓
- 통신을 하기 위한 endpoint
- IP + Port
- 클라이언트 - 서버 구조
- 구조화되지 않은 바이트 스트림만을 통신함 -> 해석하는 것은 클라이언트와 서버 몫이므로 낮은 수준
#### 4) RPC
- 원격 프로시저 호출 (Remote Procedure Calls)
#### 5) 메시지 큐

# 스레드
- 프로세스 내에서 실제로 작업을 수행하는 주체
#### 1. 싱글 스레드
![](https://i.imgur.com/s8w28Uc.png)

웹 사이트 내에서 사진, 음악, 영상을 다운받으면서 클라이언트의 요청을 처리할 때, 싱글 스레드라면 클라이언트의 요청이 서비스되기까지 매우 긴 시간이 걸림
#### 2. 멀티 스레드
![](https://i.imgur.com/sZAS1Nh.png)

서버가 클라이언트의 요청을 listen하는 스레드를 생성해 클라이언트의 요청을 들으며, 클라이언트 요청 발생 시 다른 프로세스를 생성하는 것이 아닌 **스레드**를 생성